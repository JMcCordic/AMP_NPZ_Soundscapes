---
title: "Dissimilarity_calc"
author: "Jessica McCordic"
date: "2025-08-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load lib and data}

library(tidyverse)


# read in CSV with summarized PSD to compare
psd_og <- read_csv("data/Df_analysis/All_deps_weekly_PSD.csv")



# pivot wider to create new df with one column per deployment-month combination
psd_wide <- psd_og |>
  # only keep data from full weeks
  filter(effort_days == 7)|>
  # drop quantiles not using
  select(Dep_ID, isoweek_UTC, frequency, qmed)|>
  # new col names = Deployment_month_effortdays
  pivot_wider(names_from = c(Dep_ID, isoweek_UTC), values_from = c(qmed))

# psd_wide_northwest <- psd_og |>
#   # only keep data from full weeks
#   filter(effort_days == 7,
#          network == "Northwest")|>
#   # drop quantiles not using
#   select(Dep_ID, isoweek_UTC,  frequency, qmed)|>
#   # new col names = Deployment_month_effortdays
#   pivot_wider(names_from = c(Dep_ID, isoweek_UTC), values_from = c(qmed))
# 
# 
# psd_wide_southwest <- psd_og |>
#   # only keep data from full weeks
#   filter(effort_days == 7,
#          network == "South-west")|>
#   # drop quantiles not using
#   select(Dep_ID, isoweek_UTC, frequency, qmed)|>
#   # new col names = Deployment_month_effortdays
#   pivot_wider(names_from = c(Dep_ID, isoweek_UTC), values_from = c(qmed))



```


Function for calculating dissimilarity between spectra

```{r dissim}


dissim_calc <- function( 
    # first PSD
  spec1 = numeric(),
  # second PSD
  spec2 = numeric(),
  # vector with frequency bins
  freqs = numeric(),
  # specify fmin and fmax if subsetting frequency range
  fmin = numeric(), 
  fmax = numeric()){
  
  
  # based on sound_Df matlab function from Becca
  
  #' Inputs
  #'  spec1 = median spectra of time series 1
  #'  spec2 = median spectra of time series 2
  #'  
  #'  freqs = vector of frequencies in spectra (same length as specs)
  #'    for HMD data, should be named column in HMD df
  #'    
  #'  c(f1, f2) = specific frequency range of interest
  #'    If using full spectra, f1 = min(freqs), f2 = max(freqs)
  #'    
  
  # Trim spectra to freq range if fmin and fmax provided
  # if they are not specified, use whole freq range
  
  if(missing(fmin) & missing(fmax)){
    f1 <- min(freqs)
    f2 <- max(freqs)
  } else {
    f1 <- fmin
    f2 <- fmax
  }
  
  
  # index to subset frequencies
  f_range <- which(freqs >= f1 & freqs <= f2)
  
  # normalize PSD
  
  # normalized PSD = level at each freq / sum of levels across all freqs
  n_spec1 <- spec1[f_range] / sum(spec1[f_range])
  n_spec2 <- spec2[f_range] / sum(spec2[f_range])
  
  # sanity check -- should sum to 1
  # --> could maybe add this in as a Warning?
  sum(n_spec1)
  sum(n_spec2)
  
  # Calculate dissimilarity between normalized spectra
  # "integral of pointwise differences" based on Sueur et al. 2008, cited in Lellouch et al. 2014
  
  dissim <- 0.5*(sum(abs(n_spec1 - n_spec2)))
  
  return(dissim)
  
}


# test function in a pipe
psd_wide |>
  summarize(dissim = dissim_calc(spec1 = PARKSAUSTRALIA_CGMP_201807_CG_7_30, 
              spec2 = PARKSAUSTRALIA_SWC_202201_SWS_2_28, 
              freqs = frequency))

# ------------------------------------------------------
# Matlab version below:
# % sound_Df calculates the spectral dissimilarity between two mean spectra
# 
# % Inputs
# % S1 = average (or median) spectra of time series 1
# % S2 = average (or median) spectra of time series 2
# % f = frequency vector
# % [f1 f2] = frequency range of interest --> used to trim spectra 
# 
# % NOTE: using median spectra for each site - when using mean, trend is
# % similar in highband but large variability in lowband inflates SPLs so
# % that spectra looks a little different
# 
# % Attemped Jan 2018 OC
# 
# % trim spectra and calculate pdf (mean spectra normalized by total power)
# 
# a=find(f>f1 & f<f2); 
# 
# Sf1=S1(a)/sum(S1(a));
# Sf2=S2(a)/sum(S2(a));
# sum(Sf2)  %should sum to 1
# sum(Sf1)
# 
# % D calculation
# Df=(1/2)*sum(abs(Sf1-Sf2));
# 
# 
# % plotting
# if plt==1
#     figure; subplot(1,2,1); semilogx(f(a),Sf1,'b'); hold on; semilogx(f(a),Sf2,'r'); %plot normalized data
#     subplot(1,2,2); semilogx(f(a),S1(a),'b'); hold on; semilogx(f(a),S2(a),'r');  %plot non-normalized data
# end
# end

```


Creating dissimilarity matrix
```{r pairwise setup}

# what I want it to do:

# For each combination of columns
# calculate dissimilarity between columns
# store in matrix

# pairwise operations adapted largely from this approach:
# https://www.bryanshalloway.com/2020/06/03/tidy-2-way-column-combinations/

# nest & pivot to get lists of values as columns within new df
# change input psd dataframe manually (for now). At some point would be nice to wrap into a function to make the matrix
df_lists <- psd_wide |>
  summarize_all(list) |>
  pivot_longer(cols = c(-frequency), 
               names_to = "dep",
               values_to = "psd_lev") |>
  select(-frequency)

# expand combinations to make all 2-way combos

df_lists_combos <- expand(df_lists, 
                          nesting(dep, psd_lev),
                          nesting(dep2 = dep, psd_lev2 = psd_lev)) |>
  # filter(dep != dep2) |>
  arrange(dep, dep2) |>
  mutate(dep_pwise = paste0(dep, ".", dep2)) |>
  select(contains("dep"), everything())

# now each row contains relevant combinations of variables



```

Calculate dissimilarity value over pairwise combinations of deployment-months

```{r dissim calc}

# assign frequency bins ahead of time
# -- probably not needed, but it makes the map2() operation slightly less confusing?
freqs = psd_wide$frequency

dissim_vals <- df_lists_combos |>
  mutate(dissim_value = map2(psd_lev, psd_lev2, 
                             # use tilde operator and specify .x and .y as inputs
                             ~dissim_calc(.x, .y, freqs = freqs))) |>
  # remove list-columns of psd values to make it less cumbersome
  select(-c(psd_lev, psd_lev2))|>
  # change dissimilarity values from list to numeric
  mutate(dissim_value = as.numeric(dissim_value))

# omg it worked!!!

# plot values in heatmap to check
ggplot(data = dissim_vals) +
  geom_tile(aes(x = dep, 
                y = dep2, 
                fill = dissim_value)) +
  scale_fill_viridis_c()+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90))
# woohoo!
# 
# ggsave("figs/dissim_matrix_dep_week_all.jpg", device = "jpeg",
#        width=12, height=12, units="in", dpi=600)

```


Rearrange into symmetric matrix and save as CSV

```{r rearrange df matrix}

dissim_matrix <- dissim_vals |>
  pivot_wider(id_cols = dep, 
              id_expand = TRUE,
              names_from = dep2, 
              values_from = dissim_value)

# Save dissimilarity matrix
write_csv(dissim_matrix,
          "output/dissim_matrix_dep_week.csv")



```











